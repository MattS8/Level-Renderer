# DEV4 Simple Level Exporter v1.0
# a simple export script based on this answer from Blender stack exchange:
# https://blender.stackexchange.com/a/146344

import bpy
import os
from bpy_extras.io_utils import axis_conversion
import mathutils
import math

print("----------Begin Level Export----------")

path = os.path.join(os.path.dirname(bpy.data.filepath), "GameLevel.txt")
file = open(path,"w")
file.write("# Game Level Exporter v1.0\n")

scene = bpy.context.scene

def print_camera(spaces, ob):
    print(spaces, ob.type)
    print(spaces, ob.name)
    print(spaces, ob.matrix_world)
    print(spaces + ' <FOV ' + str(ob.data.angle_x) + ' >')
    print(spaces + ' <Near ' + str(ob.data.clip_start) + ' >')
    print(spaces + ' <Far ' + str(ob.data.clip_end) + ' >')


def print_heir(ob, levels=10):
    def recurse(ob, parent, depth):
        if depth > levels: 
            return
        # spacing to show hierarchy
        spaces = "  " * depth;
        # print to system console for debugging
        if (ob.type == 'CAMERA'):
            print_camera(spaces, ob)
        else:
            print(spaces, ob.type)
            print(spaces, ob.name)
            print(spaces, ob.matrix_world)
        # send to file
        file.write(spaces + ob.type + "\n")
        file.write(spaces + ob.name + "\n")
        
        # swap from blender space to vulkan/d3d 
        # { rx, ry, rz, 0 } to { rx, rz, ry, 0 }  
        # { ux, uy, uz, 0 }    { ux, uz, uy, 0 }
        # { lx, ly, lz, 0 }    { lx, lz, ly, 0 } 
        # { px, py, pz, 1 }    { px, pz, py, 1 }  
        row_world = ob.matrix_world.transposed()
        converted = mathutils.Matrix.Identity(4)
        converted[0][0:3] = row_world[0][0], row_world[0][2], row_world[0][1]
        converted[1][0:3] = row_world[1][0], row_world[1][2], row_world[1][1] 
        converted[2][0:3] = row_world[2][0], row_world[2][2], row_world[2][1] 
        converted[3][0:3] = row_world[3][0], row_world[3][2], row_world[3][1]  
        
        # flip the local Z axis for winding and transpose for export
        scaleZ = mathutils.Matrix.Scale(-1.0, 4, (0.0, 0.0, 1.0))
        converted = scaleZ.transposed() @ converted  
        file.write(spaces + str(converted) + "\n")
         
        # print camera-specific data
        if (ob.type == 'CAMERA'):
            file.write(spaces + '<FOV ' + str(ob.data.angle) + ' >\n')
            file.write(spaces + '<Near ' + str(ob.data.clip_start) + ' >\n')
            file.write(spaces + '<Far ' + str(ob.data.clip_end) + ' >\n')

        # TODO: For a game ready exporter we would
        # probably want the delta(pivot) matrix, lights,
        # detailed mesh hierarchy information
        # and bounding box/collission data at minimum

        for child in ob.children:
            recurse(child, ob,  depth + 1)
    recurse(ob, ob.parent, 0)

root_obs = (o for o in scene.objects if not o.parent)

for o in root_obs:
    print_heir(o)
    
file.close()

# EXPORTING OBJ SECTION (Author: Sai Shekhar) (Modified by: Matthew Steinhrdt)

# Setting the pivot/"origin" of the object to the centre of mass made no difference to the exported obj
# From what I understand, that origin is like a pivot you can use in blender to transform around.
# For more info you can check out https://docs.blender.org/manual/en/latest/scene_layout/object/origin.html
# So instead of changing the origin, I move all the objects to the centre, export them, then move it back


# Get the path where the blend file is located
# If you would like to change the export location, please change this filepath below. By default
# this would export it to the same directory as the blend file
basedir = bpy.path.abspath('//')

# Deselect all objects
bpy.ops.object.select_all(action='DESELECT')    

# loop through all the objects in the scene
scene = bpy.context.scene
for ob in scene.objects:
    # Select each object
    ob.select_set(True)

    # Make sure that we only export meshes(Only centers mesh objects for now, can change this later
    # to include light,etc)
    
    if ob.type == 'MESH':
        #oldLoc = ob.location.copy()
        #ob.location = (0,0,0)
        # Export the currently selected object to its own file based on its name
        bpy.ops.export_scene.obj(
                #change '_autoGenerated.obj' to '.obj' to remove the suffix(once verified, because you might not want to lose your old data)
                filepath=os.path.join(basedir, ob.name + '.obj'),
                use_selection=True,
                
                # you can change the orientation of the export here
                # you can also delete this line to export obj with the
                # default orientation
                axis_forward='-Z', axis_up='Y'
                )
    # Deselect the object and move on to another if any more are left
        #ob.location = oldLoc
    ob.select_set(False)

# starting the .exe which generates the .h2b and .h for each file
os.startfile("Obj2Header.exe")

print("----------End Level Export----------")

# check the blender python API docs under "Object(ID)"
# that is where I found the "type" and "matrix_world"
# there is so much more useful stuff for a game level!